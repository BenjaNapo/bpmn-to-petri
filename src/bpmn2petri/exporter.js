import { PetriNet, Place, Transition, Arc, XORJoin, XORSplit, ANDJoin, ANDSplit } from './petrinet.js';
import Config from './config.js';

/**
 * Exporter class to export the Petri net to PNML and Graphviz
 * 
 * @class Exporter
 * @param {PetriNet} petrinet - The Petri net to export
 * @property {PetriNet} petrinet - The Petri net to export
 * @property {string} result - The PNML result
 * @property {Object} pools - The PNML results for each pool
 * @property {string} graphviz - The Graphviz result
 * @property {number} nodeSize - The size of the nodes in the PNML
 * @property {boolean} withDecorators - Whether to include decorators in the PNML
 */
class Exporter {
    constructor(petrinet) {
        this.petrinet = petrinet;
        this.result = "";
        this.pools = {};
        this.graphviz = "";
        this.nodeSize = Config.nodeSize;
        this.withDecorators = Config.withDecorators;
        this.scale = Config.scale;
    }
    
    /**
     * Export the Petri net to PNML
     * 
     * @param {string} process - The process id to export, if null exports the whole Petri net
     */
    export(process = null) {
        let xmlDoc = document.implementation.createDocument("", "pnml", null);
        let net = xmlDoc.createElement("net");
        let pnml = xmlDoc.documentElement;
        pnml.setAttribute("type", "http://www.informatik.hu-berlin.de/top/pntd/ptNetb");
        pnml.setAttribute("id", "noID");
        pnml.appendChild(net);

        this.petrinet.places.forEach(place => {
            if(place.process === process || process === null)
                this.exportNode(place, "place", net, xmlDoc);
        });
        this.petrinet.transitions.forEach(transition => {
            if(transition.process === process || process === null)
                this.exportNode(transition, "transition", net, xmlDoc);
        });
        this.petrinet.arcs.forEach(arc => {
            if(arc.process === process || process === null)
                this.exportArc(arc, net, xmlDoc);
        });

        let ret = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        ret += "<!--PLEASE DO NOT EDIT THIS FILE\nCreated with bpmn-to-petri-->\n";
        ret += this.prettifyXml(new XMLSerializer().serializeToString(xmlDoc));
        
        if(process === null)
            this.result = ret;
        else
            this.pools[process] = ret;
    }

    /**
     * Export the whole Petri net and all processes in the format PNML
     */
    exportAll() {
        this.export();
        for(let process in this.petrinet.processes)
            this.export(process);
        this.exportGraphviz();
    }

    /**
     * Export a single node to PNML
     * 
     * @param {Node} node - The node to export
     * @param {string} type - The type of the node (place or transition)
     * @param {Element} net - The net element to append the node to
     * @param {Document} xmlDoc - The XML document
     */
    exportNode(node, type = "place", net, xmlDoc) {
        let ogNode = node;
        if(node instanceof XORSplit || node instanceof XORJoin) {
            node = node.ref;
            type = node.ref instanceof Place ? "place" : "transition";
        }
        let tag = type === "place" ? "place" : "transition";
        const nodeEl = xmlDoc.createElement(tag);
        nodeEl.setAttribute("id", node.id);
        let name = xmlDoc.createElement("name");
        let text = xmlDoc.createElement("text");
        text.textContent = node.name;
        name.appendChild(text);
        let textGraphics = xmlDoc.createElement("graphics");
        let textPosition = xmlDoc.createElement("position");
        textPosition.setAttribute("x", node.getX() * this.scale);
        textPosition.setAttribute("y", node.getY() * this.scale);
        textGraphics.appendChild(textPosition);
        name.appendChild(textGraphics);
        nodeEl.appendChild(name);
        let graphics = xmlDoc.createElement("graphics");
        let position = xmlDoc.createElement("position");
        position.setAttribute("x", node.getX() * this.scale);
        position.setAttribute("y", node.getY() * this.scale);
        graphics.appendChild(position);
        let dimension = xmlDoc.createElement("dimension");
        dimension.setAttribute("x", this.nodeSize);
        dimension.setAttribute("y", this.nodeSize);
        graphics.appendChild(dimension);
        nodeEl.appendChild(graphics);

        if(type === "place") {
            let initialMarking = xmlDoc.createElement("initialMarking");
            let marking = xmlDoc.createElement("text");
            marking.textContent = node.tokens;
            initialMarking.appendChild(marking);
            nodeEl.appendChild(initialMarking);
        }
        
        if(this.withDecorators && (node instanceof ANDSplit || node instanceof ANDJoin)) {
            let toolspecific = xmlDoc.createElement("toolspecific");
            toolspecific.setAttribute("tool", "WoPeD");
            toolspecific.setAttribute("version", "1.0");
            let operator = xmlDoc.createElement("operator");
            operator.setAttribute("id", node.id);
            operator.setAttribute("type", node instanceof ANDSplit ? "101" : "102");
            toolspecific.appendChild(operator);
            nodeEl.appendChild(toolspecific);
        }
        if(this.withDecorators && (ogNode instanceof XORJoin || ogNode instanceof XORSplit)) {
            let toolspecific = xmlDoc.createElement("toolspecific");
            toolspecific.setAttribute("tool", "WoPeD");
            toolspecific.setAttribute("version", "1.0");
            let operator = xmlDoc.createElement("operator");
            let operatorId = node.id.substring(0, node.id.lastIndexOf("_op"));
            operator.setAttribute("id", operatorId);
            operator.setAttribute("type", node instanceof XORSplit ? "104" : "105");
            toolspecific.appendChild(operator);
            nodeEl.appendChild(toolspecific);
        }
        
        net.appendChild(nodeEl);
    }

    /**
     * Export a single arc to PNML
     * 
     * @param {Arc} arc - The arc to export
     * @param {Element} net - The net element to append the arc to
     * @param {Document} xmlDoc - The XML document
     */
    exportArc(arc, net, xmlDoc) {
        let arcEl = xmlDoc.createElement("arc");
        arcEl.setAttribute("id", arc.id);
        arcEl.setAttribute("source", arc.source.id);
        arcEl.setAttribute("target", arc.target.id);
        if(arc.waypoints.length > 0) {
            let graphics = xmlDoc.createElement("graphics");
            arc.waypoints.forEach(waypoint => {
                let point = xmlDoc.createElement("position");
                point.setAttribute("x", waypoint.x * this.scale + this.nodeSize / 2 );
                point.setAttribute("y", waypoint.y * this.scale + this.nodeSize / 2);
                graphics.appendChild(point);
            });
            arcEl.appendChild(graphics);
        }
        net.appendChild(arcEl);
    }

    /**
     * Get the PNML result
     * 
     * @returns {string} The PNML result
     */
    getResult() {
        return this.result;
    }

    /**
     * Get the PNML results for each pool
     * 
     * @returns {Object} The PNML results for each pool
     */
    getPools() {
        return this.pools;
    }

    /**
     * Get the Graphviz result
     * 
     * @returns {string} The Graphviz result
     */
    getGraphviz() {
        return this.graphviz;
    }

    /**
     * Transform the XML to a prettified version
     * 
     * @param {string} sourceXml - The XML to prettify
     * @returns {string} The prettified XML
     */
    prettifyXml(sourceXml) {
        var xmlDoc = new DOMParser().parseFromString(sourceXml, 'application/xml');
        var xsltDoc = new DOMParser().parseFromString([
            // describes how we want to modify the XML - indent everything
            '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
            '  <xsl:strip-space elements="*"/>',
            '  <xsl:template match="para[content-style][not(text())]">', // change to just text() to strip space in text nodes
            '    <xsl:value-of select="normalize-space(.)"/>',
            '  </xsl:template>',
            '  <xsl:template match="node()|@*">',
            '    <xsl:copy><xsl:apply-templates select="node()|@*"/></xsl:copy>',
            '  </xsl:template>',
            '  <xsl:output indent="yes"/>',
            '</xsl:stylesheet>',
        ].join('\n'), 'application/xml');

        var xsltProcessor = new XSLTProcessor();    
        xsltProcessor.importStylesheet(xsltDoc);
        var resultDoc = xsltProcessor.transformToDocument(xmlDoc);
        var resultXml = new XMLSerializer().serializeToString(resultDoc);
        return resultXml;
    }

    /**
     * Export the Petri net to Graphviz
     * 
     * @param {boolean} textOutside - Whether to put the text outside the nodes
     * @returns {string} The Graphviz result
     */
    exportGraphviz(textOutside = true) {
        let labelStr = textOutside ? "xlabel" : "label";
        let emptyLabel = textOutside ? 'label="",' : "";
        let ret = "digraph G {\n";
        this.petrinet.places.forEach(place => {
            ret += `  ${place.id} [${emptyLabel} ${labelStr}="${place.name}", shape="circle"];\n`;
        });
        this.petrinet.transitions.forEach(transition => {
            ret += `  ${transition.id} [${emptyLabel} ${labelStr}="${transition.name}", shape="square"];\n`;
        });
        this.petrinet.arcs.forEach(arc => {
            ret += `  ${arc.source.id} -> ${arc.target.id};\n`;
        });
        ret += "}";
        this.graphviz = ret;
        return ret;
    }
}

export default Exporter;